<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>ORC Tutorial: Protocol Specification</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->

	<script src="scripts/highlight.min.js"></script>

	<link type="text/css" rel="stylesheet" href="styles/site.cyborg.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top ">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" style="background-image:url()"  href="index.html">ORC</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="modules.list.html" class="dropdown-toggle" data-toggle="dropdown">Modules<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="module-orc.html">orc</a></li><li><a href="module-orc_constants.html">orc/constants</a></li><li><a href="module-orc_profiles.html">orc/profiles</a></li><li><a href="module-orc_utils.html">orc/utils</a></li><li><a href="module-orc_version.html">orc/version</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Audit.html">Audit</a></li><li><a href="Bridge.html">Bridge</a></li><li><a href="Contract.html">Contract</a></li><li><a href="module-orc_profiles-FarmerProfile.html">orc/profiles~FarmerProfile</a></li><li><a href="module-orc_profiles-Profile.html">orc/profiles~Profile</a></li><li><a href="module-orc_profiles-RenterProfile.html">orc/profiles~RenterProfile</a></li><li><a href="Node.html">Node</a></li><li><a href="Offers.html">Offers</a></li><li><a href="Proof.html">Proof</a></li><li><a href="Rules.html">Rules</a></li><li><a href="Server.html">Server</a></li><li><a href="Shards.html">Shards</a></li><li><a href="Transport.html">Transport</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="events.list.html" class="dropdown-toggle" data-toggle="dropdown">Events<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Offers.html#event:data">Offers#event:data</a></li><li><a href="Offers.html#event:end">Offers#event:end</a></li><li><a href="Offers.html#event:error">Offers#event:error</a></li><li><a href="Server.html#event:error">Server#event:error</a></li><li><a href="Server.html#event:shardDownloaded">Server#event:shardDownloaded</a></li><li><a href="Server.html#event:shardUploaded">Server#event:shardUploaded</a></li><li><a href="Transport.html#event:download">Transport#event:download</a></li><li><a href="Transport.html#event:upload">Transport#event:upload</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="tutorials.list.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="tutorial-config.html">Node Configuration & Setup</a></li><li><a href="tutorial-protocol.html">Protocol Specification</a></li>
				</ul>
			</li>
			
		</ul>
		<div class="col-sm-3 col-md-4">
            <form class="navbar-form" role="search">
                <div class="input-group">
                    <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                    <div class="input-group-btn">
                        <button class="btn btn-primary" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                    </div>
                </div>
            </form>
        </div>
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			<section class="tutorial-section">

<header>
    

    <h2>Protocol Specification</h2>
</header>

<article>
    <h1>Orc Protocol Specification</h1><h3>Version 2.1 (June 7, 2017)</h3><p>Gordon Hall (gordonh@member.fsf.org)<br>Braydon Fuller (braydon@storj.io)<br>Ryan Foran (ryan@storj.io)</p>
<hr>
<h2>0    License</h2><p>Copyright (C) 2017 Gordon Hall (Orc Protocol)<br>Copyright (C) 2017 Storj Labs, Inc. (Storj Protocol)</p>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3
or any later version published by the Free Software Foundation;
with no Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.
A copy of the license is included in the &quot;LICENSE&quot; file.</p>
<h2>1    Introduction</h2><p>This specification documents the Orc network protocol in its entirety for 
the purpose of enabling its implementation in other languages. Described here, 
is the protocol <strong>base</strong> - the minimum specification for compatibility with 
the Orc network. Additional optional extensions to this work are defined as 
<a href="https://github.com/orcprojects/imps">Orc Improvement Proposals</a> (or &quot;IMPs&quot;), some 
of which have been folded into the base protocol since Version 1, such as SIP-4 
and SIP-32 (Storj Protocol).</p>
<h3>1.1    Differences from Version 1</h3><ul>
<li>All node identities are now hierarchically deterministic <em>(2 Identities)</em></li>
<li><code>FIND_TUNNEL</code> and <code>OPEN_TUNNEL</code> removed from protocol</li>
<li>Introduces capacity publications <em>(6.4 Announcing Capacity)</em></li>
<li>RPC message format changed <em>(4.1 Structure and Authentication)</em></li>
<li>New <code>CLAIM</code> messages allow direct claim of available space <em>(4.11 CLAIM)</em></li>
<li>Clock synchronization with NTP no longer required</li>
<li>Nodes communicate exclusively using TLS</li>
</ul>
<h2>2    Identities</h2><p>Every node (host computer speaking the Orc protocol) on the network possesses 
a unique cryptographic identity. This identity is used to derive a special 
160 bit identifier for the purpose of organizaing the overlay structure and 
routing messages <em>(3.1: Kademlia)</em>. In order for a node to join the network it 
must generate an identity.</p>
<p>Identities are described as <strong>hierarchically deterministic</strong> and serve the 
purpose of running a cluster of nodes that can all share the same contracts 
and act on behalf of each other in the network. The specification extends 
Bitcoin ECDSA derivation standard 
<a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki">BIP32</a> and 
<a href="https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki">BIP43</a>.</p>
<p>Key derivation must match the specification of Bitcoin Hierarchical 
Deterministic Wallets (BIP32) with the purpose field described in Bitcoin 
Purpose Field for Deterministic Wallets (BIP43).</p>
<p>We define the following levels in BIP32 path:</p>
<pre class="prettyprint source"><code>m / purpose' / group_index' / node_index</code></pre><p>The apostrophe in the path indicates that BIP32 hardened derivation is used. 
Purpose is a constant set to 3000, so as to not collide with any bitcoin 
related proposals which recommends to use the BIP number.</p>
<pre class="prettyprint source"><code>m / 3000' / group_index' / node_index</code></pre><p>The <code>group_index</code> for most purposes will be 0. However is reserved for a future 
use to be able to increment in the case that the contracts should be updated 
with a new key. The <code>node_index</code> can be a number from 0 through 2 ^ 31 - 1, so 
that it's using a non-hardened paths and it's always possible to derive the 
public key for a node using the <code>m / 3000' / group_index'</code> derived extended 
public key. This gives a total of 2.147 billion possible nodes to run in a 
group cluster.</p>
<blockquote>
<p>As noted in BIP32, a compromised private key at the <code>node_index</code> level in 
combination with the extended public key at the <code>group_index</code> level will 
compromise all descending private keys derived from the <code>group_index</code> level, 
this is the rationale for a hardened path for the <code>group_index</code>.</p>
</blockquote>
<p>In every message exchanged on the network, each party will include a tuple 
structure which includes enough information to locate and authenticate each 
party.</p>
<pre class="prettyprint source"><code>[&quot;&lt;node_id>&quot;, { /* &lt;contact> */ }]</code></pre><h3>2.1    Node ID Generation</h3><p>Once a HD identity has been generated, a child identity should be derived and 
used for a single node. The resulting public key from that child identity is 
used to derive the Node ID. The node's identifier is the 
<code>RIPEMD160( SHA256( CHILD_PUBLIC_KEY ) )</code> encoded in hexidecimal. This value 
is inserted as the first item in the identity tuple.</p>
<pre class="prettyprint source"><code>[&quot;705e93f855e60847fda4c48adff0dc1b1f7c40ef&quot;, { /* &lt;contact> */ }]</code></pre><h3>2.2    Contact Hash Map</h3><p>The second entry in the identity tuple contains additional information specific 
to addressing the node on the network. This includes:</p>
<pre class="prettyprint source"><code>{
  &quot;hostname&quot;: &quot;ip.address.or.domain.name&quot;,
  &quot;port&quot;: 8443,
  &quot;protocol&quot;: &quot;https:&quot;,
  &quot;xpub&quot;: &quot;&lt;child_identity_public_extended_key>&quot;,
  &quot;index&quot;: &quot;&lt;child_identity_derivation_index>&quot;
}</code></pre><p>Additional properties may be included based on individual use cases within the 
network, however the properties above are <strong>required</strong>.</p>
<h2>3    Network Structure</h2><p>Orc employs a <strong>structured</strong> network, meaning that nodes are organized and 
route messages based on a deterministic metric. The network uses a 
<a href="http://www.scs.stanford.edu/~dm/home/papers/kpos.pdf">Kademlia</a> distributed 
hash table as the basis for the network overlay. In addition to Kademlia, 
Orc also employs other extensions to mitigate issues and attacks defined 
by the work on <a href="http://www.tm.uka.de/doc/SKademlia_2007.pdf">S/Kademlia</a>. </p>
<p>In addition to the distributed hash table, Orc also implements a 
publish-subscribe system, 
<a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/iptps08-quasar.pdf">Quasar</a>, 
atop the Kademlia overlay to provide effective delivery of publications related 
to the solicitation of storage space <em>(6: Storage Contracts)</em>.</p>
<h3>3.1    Kademlia</h3><p>Once an Orc node has completed generating its identity, it bootstraps its 
routing table by following the Kademlia &quot;join&quot; procedure. This involves 
querying a single known &quot;seed&quot; node for contact information about other nodes 
that possess a Node ID that is close (XOR distance) to its own 
_(4.4 FIND<em>NODE)</em>. This is done iteratively, sending the same query to the 
<code>ALPHA</code> (3) results that are closest, until the further queries no longer 
yield results that are closer or the routing table is sufficiently 
bootstrapped.</p>
<h3>3.2    Quasar</h3><p>Upon successfully bootstrapping a routing table, a node may choose to subscribe 
to certain publication topics related to types of storage contracts they wish 
to accept <em>(6.2 Topic Codes)</em>. Each node in the network, maintains an 
attenuated <a href="https://en.wikipedia.org/wiki/Bloom_filter">bloom filter</a>, meaning 
a <strong>list</strong> of exactly 3 bloom filters, each containing the the topics in which 
neighboring nodes are interested.</p>
<pre class="prettyprint source"><code>Filter 0 [...] - WE are subscribed
Filter 1 [...] - 3 NEAREST NEIGHBORS are subscribed
Filter 2 [...] - NEIGHBORS' 3 NEAREST NEIGHBORS' are subscribed</code></pre><p>The Orc network expects these blooms filters to be constructed and modified 
in a specific manner. Each filter's bitfield must be exactly 160 bits in size.
Items are hashed with 
<a href="https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function">FNV</a> 
in a manner consistent with the paper 
<a href="http://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf">&quot;Less Hashing, Same Performance: Building a Better Bloom Filter&quot;</a> 
using 2 slices. To illustrate the hashing in pseudo-code:</p>
<pre class="prettyprint source"><code>function calc(key, size = 160, slices = 2) {
  function fnv(seed, data) {
    const hash = new FNV();

    hash.update(seed);
    hash.update(data);

    return hash.value() >>> 0;
  }

  const hash1 = fnv(Buffer.from([83]), key);
  const hash2 = fnv(Buffer.from([87]), key);
  const hashes = [];

  for (let i = 0; i &lt; slices; i++) {
    hashes.push((hash1 + i * hash2) % size);
  }

  return hashes;
}</code></pre><p>The above example illustrates how to calculate the values to insert into a 
bloom filter for a given key (or topic code). To subscribe to a given topic, 
the code(s) should be processed as shown above and then inserted into the 
filter at index 0. Once the filter at index 0 represents what the node wants
to receive, it must exchange this information with its 3 nearest neighbors 
<em>(4.7 SUBSCRIBE + 4.8 UPDATE)</em>. This allows publications to be properly 
relayed to nodes who are most likely to be subscribed to the given topic.</p>
<h3>3.3    Transport</h3><p>The Orc network operates entirely over HTTPS. TLS <em>must</em> be used - there is 
no cleartext supported. In general this means that certificates are self-signed 
and you must accept them in order to communicate with others on the network. 
In addition, Orc operates exclusively over <a href="https://torproject.org">Tor</a> and 
because of this, there is no need to perform certificate pinning for SSL since 
all Orc nodes are Tor hidden services and authentication is performed by the 
nature of Tor's routing.</p>
<p>Each Orc node exposes endpoints to other nodes; one for receiving RPC 
messages <em>(4. Remote Procedure Calls)</em>, one for serving and accepting 
raw data streams associated with held contracts <em>(5. Data Transfer Endpoints)</em>,
and one for delivering identity metadata to requesters <em>(3.4 Root Endpoint)</em>.</p>
<p>Requests sent to the RPC endpoint require a special HTTP header 
<code>x-kad-message-id</code> to be included that matches the <code>id</code> parameter in the 
associated RPC message <em>(4.1 Structure and Authentication)</em>.</p>
<h3>3.4 Root Endpoint</h3><p>Whenver an Orc node receives a GET request at the root path (<code>/</code>), it must 
with it's contact metadata:</p>
<pre class="prettyprint source"><code>[&quot;705e93f855e60847fda4c48adff0dc1b1f7c40ef&quot;, { /* &lt;contact> */ }]</code></pre><p>This is to enable new Orc nodes who have yet to discover this information to 
query seeds for it before bootstrapping their routing table.</p>
<h2>4    Remote Procedure Calls</h2><ul>
<li><strong>Method:</strong> <code>POST</code></li>
<li><strong>Path:</strong> <code>/rpc/</code></li>
<li><strong>Content Type:</strong> <code>application/json</code></li>
<li><strong>Headers:</strong> <code>x-kad-message-id</code></li>
</ul>
<h3>4.1    Structure and Authentication</h3><p>Each remote procedure call sent and received between nodes is composed in the 
same structure. Messages are formatted as a 
<a href="http://www.jsonrpc.org/specification">JSON-RPC 2.0</a> <em>batch</em> payload containing 
3 objects. These objects are positional, so ordering matters. The anatomy of a 
message takes the form of:</p>
<pre class="prettyprint source"><code>[{ /* rpc */ },{ /* notification */ },{ /* notification */ }]</code></pre><p>At position 0 is the RPC request/response object, which must follow the 
JSON-RPC specification for such an object. It must contain the properties: 
<code>jsonrpc</code>, <code>id</code>, <code>method</code>, and <code>params</code> if it is a request. It must contain the 
properties: <code>jsonrpc</code>, <code>id</code>, and one of <code>result</code> or <code>error</code> if it is a 
response.</p>
<p>At positions 1 and 2 are a JSON-RPC notification object, meaning that it is not 
required to contain an <code>id</code> property since no response is required. These two 
notifications always assert methods <code>IDENTIFY</code> and <code>AUTHENTICATE</code> respectively.
Together, these objects provide the recipient with information regarding the 
identity and addressing information of the sender as well as a cryptographic 
signature to authenticate the payload.</p>
<blockquote>
<p>Positions 3 and beyond in this structure are reserved for future protocol 
extensions related to global message processing.</p>
</blockquote>
<h4>Example: Request</h4><pre class="prettyprint source"><code>[
  {
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;: &quot;&lt;uuid_version_4>&quot;,
    &quot;method&quot;: &quot;&lt;method_name>&quot;,
    &quot;params&quot;: [&quot;&lt;parameter_one>&quot;, &quot;&lt;parameter_two>&quot;]
  },
  {
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;IDENTIFY&quot;,
    &quot;params&quot;: [
      &quot;&lt;public_key_hash>&quot;, 
      {
        &quot;hostname&quot;: &quot;sender.hostname&quot;,
        &quot;port&quot;: 8443,
        &quot;protocol&quot;: &quot;https:&quot;,
        &quot;xpub&quot;: &quot;&lt;public_extended_key>&quot;,
        &quot;index&quot;: &quot;&lt;child_key_derivation_index>&quot;
      }
    ]
  },
  {
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;AUTHENTICATE&quot;,
    &quot;params&quot;: [
      &quot;&lt;payload_signature>&quot;,
      &quot;&lt;child_public_key>&quot;,
      [&quot;&lt;public_extended_key>&quot;, &quot;&lt;child_key_derivation_index>&quot;]
    ]
  }
]</code></pre><h4>Example: Response</h4><pre class="prettyprint source"><code>[
  {
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;id&quot;: &quot;&lt;uuid_version_4_from_request>&quot;,
    &quot;result&quot;: [&quot;&lt;result_one>&quot;, &quot;&lt;result_two>&quot;]
  },
  {
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;IDENTIFY&quot;,
    &quot;params&quot;: [
      &quot;&lt;public_key_hash>&quot;, 
      {
        &quot;hostname&quot;: &quot;receiver.hostname&quot;,
        &quot;port&quot;: 8443,
        &quot;protocol&quot;: &quot;https:&quot;,
        &quot;xpub&quot;: &quot;&lt;public_extended_key>&quot;,
        &quot;index&quot;: &quot;&lt;child_key_derivation_index>&quot;
      }
    ]
  },
  {
    &quot;jsonrpc&quot;: &quot;2.0&quot;,
    &quot;method&quot;: &quot;AUTHENTICATE&quot;,
    &quot;params&quot;: [
      &quot;&lt;payload_signature>&quot;,
      &quot;&lt;child_public_key>&quot;,
      [&quot;&lt;public_extended_key>&quot;, &quot;&lt;child_key_derivation_index>&quot;]
    ]
  }
]</code></pre><p>In the examples above, <code>public_key_hash</code> and <code>child_public_key</code> must be encoded 
as hexidecimal strings, <code>public_extended_key</code> must be encoded as a base58 
string (in accordance with BIP32), and <code>payload_signature</code> must be encoded as a
base64 string which is the concatenation of the public key recovery number with 
the actual signature of the payload - excluding the object at index 2 
(<code>AUTHENTICATE</code>). This means that the message to be signed is 
<code>[rpc, identify]</code>.</p>
<blockquote>
<p>Note the exclusion of a timestamp or incrementing nonce in the payload means 
that a man-in-the-middle could carry out a replay attack. To combat this, it 
is urged that the <code>id</code> parameter of the RPC message (which is a universally 
unique identifier) be stored for a reasonable period of time and nodes should 
reject messages that attempt to use a duplicate UUID.</p>
</blockquote>
<p>The rest of this section describes each individual method in the base protocol 
and defines the parameter and result signatures that are expected. If any RPC 
message yields an error, then an <code>error</code> property including <code>code</code> and 
<code>message</code> should be send in place of the <code>result</code> property.</p>
<h3>4.2    <code>PROBE</code></h3><p>Upon receipt of a <code>PROBE</code> message, the node must attempt to send a <code>PING</code> 
message to the originator using the declared contact information. If 
successful, it must respond positively, otherwise error. Used for joining nodes 
to verify they are publicly addressable.</p>
<p>Parameters: <code>[]</code><br>Results: <code>[]</code></p>
<h3>4.3    <code>PING</code></h3><p>This RPC involves one node sending a <code>PING</code> message to another, which 
presumably replies. This has a two-fold effect: the recipient of the <code>PING</code> 
must update the bucket corresponding to the sender; and, if there is a reply, 
the sender must update the bucket appropriate to the recipient.</p>
<p>Parameters: <code>[]</code><br>Results: <code>[]</code></p>
<h3>4.4    <code>FIND_NODE</code></h3><p>Basic kademlia lookup operation that builds a set of K contacts closest to the 
the given key. The <code>FIND_NODE</code> RPC includes a 160-bit key. The recipient of the 
RPC returns up to K contacts that it knows to be closest to the key. The 
recipient must return K contacts if at all possible. It may only return fewer 
than K if it is returning all of the contacts that it has knowledge of.</p>
<p>Parameters: <code>[key_160_hex]</code><br>Results: <code>[contact_0, contact_1, ...contactN]</code></p>
<h3>4.5    <code>FIND_VALUE</code></h3><p>Kademlia search operation that is conducted as a node lookup and builds a list 
of K closest contacts. If at any time during the lookup the value is returned, 
the search is abandoned. If no value is found, the K closest contacts are 
returned. Upon success, we must store the value at the nearest node seen during 
the search that did not return the value.</p>
<p>A <code>FIND_VALUE</code> RPC includes a B=160-bit key. If a corresponding value is 
present on the recipient, the associated data is returned. Otherwise the RPC is 
equivalent to a <code>FIND_NODE</code> and a set of K contacts is returned.</p>
<p>If a value is returned, it must be in the form of an object with properties: 
<code>timestamp</code> as a UNIX timestamp in milliseconds, <code>publisher</code> as a 160 bit 
public key hash in hexidecimal of the original publisher, and <code>value</code> which may 
be of mixed type that is valid JSON.</p>
<p>Parameters: <code>[key_160_hex]</code><br>Results: <code>{ timestamp, publisher, value }</code> or <code>[...contactN]</code></p>
<h3>4.6    <code>STORE</code></h3><p>The sender of the <code>STORE</code> RPC provides a key and a block of data and requires 
that the recipient store the data and make it available for later retrieval by 
that key .</p>
<p>Parameters: <code>[key_160_hex, { timestamp, publisher, value }]</code><br>Results: <code>[key_160_hex, { timestamp, publisher, value }]</code></p>
<h3>4.7    <code>SUBSCRIBE</code></h3><p>Upon receipt of a <code>SUBSCRIBE</code> message, we simply respond with a serialized 
version of our attenuated bloom filter. Senders of this message must merge the 
response with their local attenuated bloom filter starting at their filter at 
index 1.</p>
<p>Parameters: <code>[]</code><br>Results: <code>[filter_0_hex, filter_1_hex, filter_2_hex]</code></p>
<h3>4.8    <code>UPDATE</code></h3><p>Upon receipt of an <code>UPDATE</code> message we merge the delivered attenuated bloom 
filter with our own. This is the inverse of <code>SUBSCRIBE</code>, where a peer requests 
a copy of our attenuated bloom filter. </p>
<p>Parameters: <code>[filter_0_hex, filter_1_hex, filter_2_hex]</code><br>Results: <code>[]</code></p>
<h3>4.9    <code>PUBLISH</code></h3><p>Upon receipt of a <code>PUBLISH</code> message, we validate it, then check if we or our 
neighbors are subscribed. If we are subscribed, we execute our handler. If our 
neighbors are subscribed, we relay the publication to ALPHA random of the 
closest K. If our neighbors are not subscribed, we relay the publication to a 
random contact.</p>
<p>The parameters for a <code>PUBLISH</code> message are named, not positional. It must be 
a JSON object containing: <code>uuid</code>, a version 4 UUID string, <code>topic</code>, the topic 
string to which a node may be subscribed, <code>publishers</code>, an array of 160 bit 
public key hash strings in hexidecimal representing nodes that have relayed the 
message previously, <code>ttl</code> the number of hops left for relaying the publication, 
and <code>contents</code>, any arbitrary valid JSON data associated with the publication.</p>
<blockquote>
<p>Given the relatively high cost of a single publication's propagation through 
the overlay, nodes should take care to implement some reasonable rate 
limiting for relay of publications. It is advisable for nodes to ignore the 
<code>ttl</code> and refuse to relay a publication if the identifier at <code>publishers[0]</code> 
is matched as the originator more than 100 times within a minute.</p>
</blockquote>
<p>Before relaying the message to others, we must add our public key hash to the 
<code>publishers</code> list and decrement the <code>ttl</code>.</p>
<p>Parameters: <code>{ uuid, topic, publishers, ttl, contents }</code><br>Results: <code>[]</code>  </p>
<h3>4.10    <code>OFFER</code></h3><p>Upon receipt of an <code>OFFER</code> message, nodes must validate the descriptor, then 
ensure that the referenced shard is awaiting allocation(s). If both checks 
succeed, then the descriptor is added to the appropriate offer processing 
stream. Once the descriptor is processed, we respond back to the originator 
with the final copy of the contract <em>(6.1 Descriptor Schema)</em>. These messages 
are generally sent based on information collected when subscribed to renter 
contract publications.</p>
<p>Parameters: <code>[descriptor_map]</code><br>Results: <code>[descriptor_map]</code></p>
<h3>4.11    <code>CLAIM</code></h3><p>Upon receipt of an <code>CLAIM</code> message, nodes must validate the descriptor, then 
ensure that there is enough available space for the shard. If both checks 
succeed, then the descriptor is signed and returned along with a consignment 
token so the initiating renter can immediately upload the data. This call is 
the functional inverse of <code>OFFER</code>, as it is used for a renter to signal 
to a farmer that it wishes to rent capacity. These messages are generally 
sent based on information collected when subscribed to farmer capacity 
publications.</p>
<p>Parameters: <code>[descriptor_map]</code><br>Results: <code>[descriptor_map, token_256_hex]</code></p>
<h3>4.11    <code>CONSIGN</code></h3><p>Upon receipt of a <code>CONSIGN</code> message, the node must verify that it has a valid 
storage allocation and contract for the supplied hash and identity of the 
originator. If so, it must generate an authorization token which will be 
checked by the shard server before accepting the transfer of the associated 
shard.</p>
<p>Parameters: <code>[hash_160_hex]</code><br>Results: <code>[token_256_hex]</code></p>
<h3>4.12    <code>AUDIT</code></h3><p>Upon receipt of an <code>AUDIT</code> message, the node must look up the contract that is 
associated with each hash-challenge pair in the payload, prepend the challenge 
to the shard data, and caclulate the resulting hash, formatted as a compact 
proof <em>(7 Retrievability Proofs)</em>.</p>
<p>Parameters: <code>[...{ hash, challenge }]</code><br>Results: <code>[...{ hash, proof }]</code> </p>
<h3>4.13    <code>MIRROR</code></h3><p>Upon receipt of a <code>MIRROR</code> message, the node must verify that it is in 
possesion of the shard on behalf of the identity or the message originator. If 
so, given the token-hash pair, it must attempt to upload it's copy of the shard 
to the target to establish a mirror. The originator must have an established 
contract with the target node and have issued a <code>CONSIGN</code> message to the target 
in advance to provide the <code>MIRROR</code> recipient with this token.</p>
<p>In addition to the hash and token, the sender must also include the target 
contact data in the form of <code>[public_key_hash, { hostname, port, xpub, index, 
protocol }]</code>.</p>
<p>Parameters: <code>[hash_160_hex, token_256_hex, target_contact]</code><br>Results: <code>[status_message_string]</code></p>
<h3>4.14    <code>RETRIEVE</code></h3><p>Upon receipt of a <code>RETRIEVE</code> message, the node must verify that it is in 
possession of the shard on behalf of the identity of the originator. If so, it 
must generate an authorization token which will be checked by the shard server 
before accepting the transfer of the associated shard.</p>
<p>Parameters: <code>[hash_160_hex]</code><br>Results: <code>[token_256_hex]</code></p>
<h3>4.15    <code>RENEW</code></h3><p>Upon receipt of a <code>RENEW</code> message, the recipient farmer must extend or 
terminate it's contract based on the new terms supplied by the renter. If the 
renewal descriptor is valid and complete, the farmer must store the updated 
version after signing and respond back to the originator with the version 
containing the updated signature <em>(6.1 Descriptor Schema)</em>.</p>
<p>Implementations should only allow certain properties to be updated: 
<code>renter_id</code>, <code>renter_hd_key</code>, <code>renter_signature</code>, <code>store_begin</code>, <code>store_end</code>, 
<code>audit_leaves</code>. If the sender has attempted to modify any other parts of the 
contract, an error should be returned.</p>
<p>Parameters: <code>[descriptor_map]</code><br>Results: <code>[descriptor_map]</code></p>
<h2>5    Data Transfer Endpoints</h2><p>Initiating the transfer of data between nodes after a contract has been signed 
is straightforward. First, the initiator must request a transfer token from the 
custodian. If uploading the shard for the first time to a farmer, a CONSIGN RPC
<em>(4.13 CONSIGN)</em> must be sent. If downloading the shard, a RETRIEVE RPC 
<em>(4.14 RETRIEVE)</em> is sent. The result of either of those messages should yield 
an authorization token that is included in the query string of the next 
request.</p>
<h3>5.1    Uploading</h3><ul>
<li><strong>Method:</strong> <code>POST</code></li>
<li><strong>Path:</strong> <code>/shards/{hash}?token={consign_token}</code></li>
<li><strong>Content Type:</strong> <code>binary/octet-stream</code></li>
</ul>
<h3>5.2    Downloading</h3><ul>
<li><strong>Method:</strong> <code>GET</code></li>
<li><strong>Path:</strong> <code>/shards/{hash}?token={retrieve_token}</code></li>
<li><strong>Content Type:</strong> <code>binary/octet-stream</code></li>
</ul>
<h2>6    Storage Contracts</h2><p>Nodes on the Orc network form agreements with each other regarding the 
storage of data by exchanging a &quot;contract descriptor&quot;. These descriptors 
are included in contract publications intended to solicit storage space 
<em>(7 Renting Space)</em> as well as in <code>RENEW</code> messages <em>(4.15 RENEW)</em>. Contracts 
describe identifying attributes of the data, the parties involved, terms of 
payment, and information about audits <em>(8 Audit Preparation)</em>.</p>
<h3>6.1    Contract Descriptor Schema</h3><p>Contracts are structured as a flat JSON dictionary and includes cryptographic 
signatures from the parties involved. The properties that compose a contract 
are show as follows.</p>
<ul>
<li><code>version</code> <em>Integer</em> Unique identifier for the contract (this is version 1)</li>
<li><code>renter_hd_key</code> <em>String</em> Node extended public key in base58</li>
<li><code>renter_hd_index</code> <em>Integer</em> Derivation index for signature</li>
<li><code>renter_id</code> <em>String</em> Node ID of the renter</li>
<li><code>renter_signature</code> <em>String</em> Renter's cryptographic signature</li>
<li><code>farmer_hd_key</code> <em>String</em> Node extended public key in base58</li>
<li><code>farmer_hd_index</code> <em>Integer</em> Derivation index for signature</li>
<li><code>farmer_id</code> <em>String</em> Node ID of the farmer</li>
<li><code>farmer_signature</code> <em>String</em> Farmer's cryptographic signature</li>
<li><code>data_size</code> <em>Integer</em> Number of bytes to store</li>
<li><code>data_hash</code> <em>String</em> RIPEMD-160 SHA-256 hash of the data</li>
<li><code>store_begin</code> <em>Integer</em> UNIX timestamp to start contract in milliseconds</li>
<li><code>store_end</code> <em>Integer</em> UNIX timestamp to end the contract in milliseconds</li>
<li><code>audit_count</code> <em>Integer</em> Number of audits renter will perform</li>
<li><code>audit_leaves</code> <em>Array</em> Merkle leaves for audit tree as hexidecimal strings</li>
<li><code>payment_storage_price</code> <em>Integer</em> Price for storage in non-divisible unit</li>
<li><code>payment_download_price</code> <em>Integer</em> Price per download in non-divisible unit</li>
<li><code>payment_destination</code> <em>String</em> Address to send funds (Etheruem)</li>
</ul>
<p>For a completed and valid contract, all fields be assigned a value and both the 
renter and farmer must sign the contract, placing their signatures in the 
respective fields. The signature is generated by using the private key 
associated with the <code>renter_id</code> or <code>farmer_id</code>, which is the hash of the public 
key. The signature field must be the result of the public key recovery number 
prepended to the actual signature of the JSON formatted descriptor exluding 
both signature fields and all other fields sorted alphanumerically. The 
signature must be encoded as a base64 string.</p>
<h3>6.2    Topic Codes</h3><p>Orc defines a matrix of <em>criteria</em> and <em>descriptors</em> in the form of codes 
representing the degree of which the criteria must be met. The resulting topic 
code is used as the key for cross-referencing neighborhood bloom filters to 
determine how the publication should be routed. At the time of writing, there 
are 4 criteria column in the topic matrix:</p>
<ul>
<li>Size: refers to the size of the data to be stored</li>
<li>Duration: refers to the length of time which the data should be stored</li>
<li>Availability: refers to the relative uptime of required by the contract</li>
<li>Speed: refers to the throughput desired for retrieval of the stored data</li>
</ul>
<p>At the time of writing, there are 3 descriptor opcodes representing <em>low</em>,
<em>medium</em>, and <em>high</em> degrees of the criteria.</p>
<ul>
<li>Low: <code>0x01</code></li>
<li>Medium: <code>0x02</code></li>
<li>High: <code>0x03</code></li>
</ul>
<blockquote>
<p>The ranges represented by these descriptors are advisory and may change based
on network performance and improvements to hardware over time.</p>
</blockquote>
<p>When publishing or subscribing to a given topic representing the degrees of
these criteria, nodes must serialize the opcodes as the hex representation of
the bytes in proper sequence. This sequence is defined as: <code>prefix + size + 
duration + availability + speed</code>.</p>
<p>The prefix byte is the static identifier for a type of publication. This may 
include both capacity announcements  <em>(6.4 Announcing Capacity)</em> and contract 
publications <em>(6.3 Renting Space)</em>. The prefix acts as a namespace for a type 
of publication topic. The prefix for a contract publication is <code>0x0f</code> and the 
prefix for a capacity announcement is <code>0x0c</code>, followed by the topic-criteria
sequence.</p>
<p>To illustrate by example, we can determine the proper topic by analyzing the
use case for a given file shard. For instance, if we want to store an asset
that is displayed on a web page we can infer the following:</p>
<ul>
<li>The file is small</li>
<li>The file may change often, so we should only store it for medium duration</li>
<li>The file needs to always be available</li>
<li>The file should be transferred quickly</li>
</ul>
<p>Using the matrix, we can determine the proper opcode sequence: <code>[0x0f, 0x01, 
0x02, 0x03, 0x03]</code>. Serialized as hex, our topic string becomes: <code>0f01020303</code>. 
Another example, by contrast, is data backup. Data backup is quite different
than the previous example:</p>
<ul>
<li>The file is large (perhaps part of a hard drive backup)</li>
<li>The file will not change and should be stored long term</li>
<li>The file will not be accessed often, if ever</li>
<li>The file does not need to be transferred at high speed</li>
</ul>
<p>Using the matrix, we can determine the proper opcode sequence: <code>[0x0f, 0x03, 
0x03, 0x01, 0x01]</code>. Serialized as hex, our topic string becomes: <code>0f03030101</code>.</p>
<h3>6.3    Renting Space</h3><p>When a node wishes to solicit storage capacity for a shard, it must know which 
nodes are both accepting contracts and have the available space. Short lived 
nodes renting data, like nodes who join for the sole purpose of storing some
data then leave, will likely not stick around long enough to track enough 
capactity announcements <em>(6.4 Announcing Capacity)</em> to build a local cache of 
known farmers with space. For these nodes, they must publish a shard descriptor 
and wait for offers from farmers as the message propagates the overlay 
<em>(3.2 Quasar + 4.10 OFFER)</em>.</p>
<p>To publish a shard descriptor, a contract must be constructed <em>(6.1 Contract 
Descriptor Schema)</em> and included in the <code>contents</code> value of a <code>PUBLISH</code> 
message <em>(4.9 PUBLISH)</em> sent to the renting node's 3 nearest neighbors to the 
<code>data_hash</code> key in the descriptor (this helps even the distribution). When 
publishing the descriptor, an appropriate topic code should be used <em>(6.2 Topic 
Codes)</em>, prefixed with <code>0x0f</code> (<code>0f</code> when serialized as hexidecimal). The 
descriptor must be as complete as possible, including values for all keys 
except for any that are prefixed with <code>farmer_</code> and <code>payment_destination</code>.</p>
<p>The <code>contents</code> property should also include the renter's contact information 
so that farmers who wish to submit offers are not required to perform a network 
walk to find the originator if it is not already in it's routing table. The 
value of this property should be:</p>
<pre class="prettyprint source"><code>[{ descriptor }, [ identity, { contact } ]]</code></pre><p>Once these messages have been dispatched, received, and acknowledged, the 
sender will begin receiving offers from farmers. The payload for these offers 
will include a completed version of the descriptor which was originally 
published, but include values for the properties prefixed with <code>farmer_</code>. The 
publisher, if it chooses to accept the completed contract, must sign the 
descriptor again and respond to the offering farmer with the finalized 
contract.</p>
<p>Once this exchange is complete, the renting node may request consignment to 
the node(s) with whom it is now contracted <em>(4.11 CONSIGN)</em> and transfer the 
shard <em>(5.1 Uploading)</em>.</p>
<h3>6.4    Announcing Capacity</h3><p>When a node joins the network and wishes to make some storage capacity 
available to others, it can subscribe to contract publication topics (using the 
<code>0x0f</code> topic code prefix) and wait for contracts for which an offer can be 
dispatched. However, in addition to this, a farming node can proactively inform 
the network that it has available space. To announce capacity, a node must send 
a <code>PUBLISH</code> message to it's 3 nearest neighbors for each topic code it is 
willing to allow, prefixed with the capacity code <code>0x0c</code> (<code>0c</code> when serialized 
as hexidecimal).</p>
<p>The <code>contents</code> property should contain the number of bytes available for claim 
along with the farmer's contact information so that renters who wish to claim 
space are not required to perform a network walk to find the originator if it 
is not already in it's routing table. The value of this property should be:</p>
<pre class="prettyprint source"><code>[ { allocated, available }, [ identity, { contact } ] ]</code></pre><p>Long lived renter nodes, like those operated by a Bridge or other similar 
directory services on the network, may subscribe to these capacity 
announcements and maintain a backlog cache of farmers who have space available.
This allows these renting nodes to directly claim space and transfer data to 
the farmer without the overhead of publishing a contract descriptor and waiting 
for offers <em>(4.11 CLAIM)</em>.</p>
<p>Farmers who announce capacity should do so on a reasonable interval to ensure 
that renters tracking their state have fresh information. It is reccommended 
to publish capacity announcements once per hour and no more than once per 15 
minutes. Nodes should take care to refuse to relay publications originating 
from an identity who has published a capacity announcement more than 100 times 
within the last hour.</p>
<h2>7    Retrievability Proofs</h2><p>When the custodian of a data shard receives an audit <em>(4.12 AUDIT)</em>, it is 
expected to respond with proof that it still in possession of the shard. This 
works by computing a retrievability proof structure from a provided challenge.
Upon receipt of a hash-challenge pair, the associated data is prepended with
the challenge bytes and hashed:</p>
<pre class="prettyprint source"><code>RIPEMD160( SHA256( CHALLENGE + DATA ) )</code></pre><p>The result of this operation yields a value that, when hashed again, equals one 
of the bottom leaves of the audit tree <em>(8 Audit Preparation)</em>. In addition to 
supplying this single-hashed value as proof that the farmer is still honoring
the terms of the contract, the farmer must also provide the uncles required to 
rebuild the merkle tree. This proof response is specified as a series of nested 
JSON arrays.</p>
<pre class="prettyprint source"><code>[[[[[&quot;&lt;response>&quot;],&quot;&lt;uncle>&quot;],&quot;&lt;uncle>&quot;],&quot;&lt;uncle>&quot;],&quot;&lt;uncle>&quot;]</code></pre><p>For clarification, given a simple merkle tree:</p>
<pre class="prettyprint source"><code>+-- HASH_0 (Root)
|   +-- HASH_1
|   |   +-- HASH_3
|   |   +-- HASH_4
|   +-- HASH_2
|   |   +-- HASH_5
|   |   +-- HASH_6 = ( RIPEMD160( SHA256( CHALLENGE_RESPONSE ) ) )</code></pre><p>The resulting format of a proof for an audit matching <code>HASH_6</code> would appear as:</p>
<pre class="prettyprint source"><code>[HASH_1, [HASH_5, [CHALLENGE_RESPONSE]]]</code></pre><p>The resulting format of a proof for an audit matching <code>HASH_3</code> would appear as:</p>
<pre class="prettyprint source"><code>[[[CHALLENGE_RESPONSE], HASH_5], HASH_2]</code></pre><p>Upon receipt of the farmer's proof, the renter must verify that the proof is
valid by using it to rebuild the merkle tree. If the proof is verified 
successfully, the renter is expected to issue a payment to the 
<code>payment_destination</code> defined in the original contract. The amount of the 
payment should be equal to: <code>payment_storage_price / audit_count</code> in addition 
to <code>payment_download_price * downloads_since_last_audit</code>.</p>
<p>If the verification fails then the contract is null and no payment is required.
Conversely, if the verification succeeds and the renter does not issue the
payment in a timely manner, then the contract is also null and the farmer may
decide to cease storage of the data.</p>
<h2>8    Audit Preparation</h2><p>Before a renter node published a contract or claims a capacity allocation, it 
must pre-calculate a series of &quot;challenges&quot;, the number of which must equal the 
<code>audit_count</code> defined in the contract descriptor and be included in the 
descriptor's <code>audit_tree</code>. A challenge is simply 32 random bytes encoded as 
hexidecimal. The generated challenges must not be shared until the renter 
wishes to issue an <code>AUDIT</code> RPC for proof-of-retrievability.</p>
<p>An <code>audit_tree</code> contains the bottom leaves of a 
<a href="https://en.wikipedia.org/wiki/Merkle_tree">Merkle Tree</a>. Each of the bottom 
leaves of the tree must be equal to the double 
<code>RIPEMD160( SHA256 ( challenge + shard ) )</code> encoded as hexidecimal. In order to 
ensure that the resulting merkle tree is properly balanced, the number of 
bottom leaves must be equal to the next power of 2 of the audit count. To 
ensure this, the additional leaves can simply be the double 
<code>RIPEMD160( SHA256 ( NULL ) )</code> (the same hash function for an audit, but 
applied to an empty buffer).</p>
<p>To audit a farmer is to request proof that it is still honoring the terms of
the storage contract without the need to have it supply the entire shard of 
data. To do this, the renter must supply the farmer with one of the secret 
pre-calculated challenges <em>(4.12 AUDIT)</em>. The receiving farmer must respond 
with a retrievability proof <em>(7 Retrievability Proofs)</em>.</p>
<h2>9    References</h2><ul>
<li>Orc Improvement Proposals (<code>https://github.com/orcproject/imps</code>)</li>
<li>BIP32 (<code>https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki</code>)</li>
<li>BIP43 (<code>https://github.com/bitcoin/bips/blob/master/bip-0043.mediawiki</code>)</li>
<li>Kademlia (<code>http://www.scs.stanford.edu/~dm/home/papers/kpos.pdf</code>)</li>
<li>S/Kademlia (<code>http://www.tm.uka.de/doc/SKademlia_2007.pdf</code>)</li>
<li>Quasar (<code>https://www.microsoft.com/en-us/research/wp-content/uploads/2008/02/iptps08-quasar.pdf</code>)</li>
<li>FNV (<code>https://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function</code>)</li>
<li>Less Hashing, Same Performance: Building a Better Bloom Filter (<code>http://www.eecs.harvard.edu/~michaelm/postscripts/rsa2008.pdf</code>)</li>
<li>Merkle Tree (<code>https://en.wikipedia.org/wiki/Merkle_tree</code>)</li>
</ul>
</article>

</section>

		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>

<div class="modal fade" id="searchResults">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
        <h4 class="modal-title">Search results</h4>
      </div>
      <div class="modal-body"></div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div><!-- /.modal-content -->
  </div><!-- /.modal-dialog -->
</div>

<footer>


	<span class="copyright">
	Copyright 2016 Gordon Hall
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>
<script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>

<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	$('pre').each(function(i, block) {
		hljs.highlightBlock(block);
	});

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			var id = $( heading ).attr( "id" );
			return id && id.replace(/\~/g, '-inner-').replace(/\./g, '-static-') || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->


<script type="text/javascript">
	$(document).ready(function() {
		SearcherDisplay.init();
	});
</script>

</body>
</html>